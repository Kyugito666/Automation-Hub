using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Spectre.Console;

namespace Orchestrator;

public static class GitHubDispatcher
{
    public static async Task TriggerAllBotsWorkflow()
    {
        AnsiConsole.MarkupLine("[cyan]Triggering workflow 'run-all-bots.yml' di GitHub Actions...[/]");

        bool success = false;
        for (int i = 0; i < 5; i++)
        {
            try
            {
                var (_, _, owner, repo) = TokenManager.GetCurrentToken();
                if (string.IsNullOrEmpty(owner) || string.IsNullOrEmpty(repo))
                {
                    AnsiConsole.MarkupLine("[red]Owner/Repo GitHub tidak dikonfigurasi di tokens.txt[/]");
                    return;
                }

                using var client = TokenManager.CreateHttpClient();
                var url = $"https://api.github.com/repos/{owner}/{repo}/actions/workflows/run-all-bots.yml/dispatches";
                
                var payload = new { @ref = "main" };
                var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

                var response = await client.PostAsync(url, content);
                
                if (response.IsSuccessStatusCode)
                {
                    AnsiConsole.MarkupLine("[green]âœ“ Workflow triggered successfully![/]");
                    AnsiConsole.MarkupLine($"[dim]Cek status: https://github.com/{owner}/{repo}/actions[/]");
                    success = true;
                    break;
                }
                
                var error = await response.Content.ReadAsStringAsync();
                AnsiConsole.MarkupLine($"[red]âœ— Failed: {response.StatusCode}[/]");
                AnsiConsole.MarkupLine($"[dim]{error}[/]");

                if (response.StatusCode == System.Net.HttpStatusCode.Forbidden || response.StatusCode == System.Net.HttpStatusCode.TooManyRequests)
                {
                    if (TokenManager.HandleRateLimitError(new Exception("Rate limit"))) continue;
                }
                
                break;
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($"[red]âœ— Exception: {ex.Message}[/]");
                if (TokenManager.HandleRateLimitError(ex)) continue;
                break;
            }
        }

        if (!success)
        {
            AnsiConsole.MarkupLine("[red]Gagal trigger workflow setelah beberapa kali percobaan.[/]");
        }
    }

    public static async Task GetWorkflowRuns()
    {
        for (int i = 0; i < 5; i++)
        {
            try
            {
                var (_, _, owner, repo) = TokenManager.GetCurrentToken();
                if (string.IsNullOrEmpty(owner) || string.IsNullOrEmpty(repo))
                {
                    AnsiConsole.MarkupLine("[red]Owner/Repo GitHub tidak dikonfigurasi di tokens.txt[/]");
                    return;
                }

                using var client = TokenManager.CreateHttpClient();
                var url = $"https://api.github.com/repos/{owner}/{repo}/actions/runs?per_page=10";
                
                var response = await client.GetAsync(url);
                response.EnsureSuccessStatusCode();

                var json = await response.Content.ReadAsStringAsync();
                var data = JsonSerializer.Deserialize<WorkflowRunsResponse>(json);

                if (data?.WorkflowRuns == null || !data.WorkflowRuns.Any())
                {
                    AnsiConsole.MarkupLine("[yellow]Tidak ada workflow runs.[/]");
                    return;
                }

                var table = new Table().Title("Recent Workflow Runs").Border(TableBorder.Rounded);
                table.AddColumn("Status");
                table.AddColumn("Workflow");
                table.AddColumn("Started");
                table.AddColumn("Duration");

                foreach (var run in data.WorkflowRuns.Take(10))
                {
                    var status = run.Status == "completed" 
                        ? (run.Conclusion == "success" ? "[green]âœ“[/]" : "[red]âœ—[/]")
                        : "[yellow]...[/]";

                    var duration = run.UpdatedAt.HasValue && run.CreatedAt.HasValue
                        ? (run.UpdatedAt.Value - run.CreatedAt.Value).ToString(@"hh\:mm\:ss")
                        : "-";

                    table.AddRow(
                        status,
                        run.Name ?? "Unknown",
                        run.CreatedAt?.ToString("yyyy-MM-dd HH:mm") ?? "-",
                        duration
                    );
                }

                AnsiConsole.Write(table);
                return;
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($"[red]âœ— Exception: {ex.Message}[/]");
                if (TokenManager.HandleRateLimitError(ex)) continue;
                return;
            }
        }
    }
    
    // NEW: Method dengan secrets injection
    public static async Task TriggerBotWithSecrets(BotEntry bot, Dictionary<string, string> capturedInputs, string? secretsBase64, int durationMinutes = 340)
    {
        AnsiConsole.MarkupLine($"[cyan]Triggering single bot: {bot.Name}...[/]");

        string inputsJson = "{}";
        try
        {
            inputsJson = JsonSerializer.Serialize(capturedInputs ?? new Dictionary<string, string>());
        }
        catch (Exception ex)
        {
            AnsiConsole.MarkupLine($"[red]Gagal serialisasi input: {ex.Message}[/]");
            return;
        }

        bool success = false;
        for (int i = 0; i < 5; i++)
        {
            try
            {
                var (_, _, owner, repo) = TokenManager.GetCurrentToken();
                if (string.IsNullOrEmpty(owner) || string.IsNullOrEmpty(repo))
                {
                    AnsiConsole.MarkupLine("[red]Owner/Repo GitHub tidak dikonfigurasi di tokens.txt[/]");
                    return;
                }

                using var client = TokenManager.CreateHttpClient();
                var url = $"https://api.github.com/repos/{owner}/{repo}/actions/workflows/run-single-bots.yml/dispatches";
                
                var payload = new
                {
                    @ref = "main",
                    inputs = new
                    {
                        bot_name = bot.Name,
                        bot_path = bot.Path,
                        bot_repo = bot.RepoUrl,
                        bot_type = bot.Type,
                        duration_minutes = durationMinutes.ToString(),
                        bot_inputs = inputsJson,
                        bot_secrets = secretsBase64 ?? "" // NEW
                    }
                };

                var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
                var response = await client.PostAsync(url, content);
                
                if (response.IsSuccessStatusCode)
                {
                    AnsiConsole.MarkupLine($"[green]âœ“ {bot.Name} triggered![/]");
                    
                    if (!string.IsNullOrEmpty(secretsBase64))
                    {
                        AnsiConsole.MarkupLine("[dim]  âœ“ Secrets injected[/]");
                    }
                    
                    success = true;
                    break;
                }

                var error = await response.Content.ReadAsStringAsync();
                AnsiConsole.MarkupLine($"[red]âœ— Failed: {response.StatusCode}[/]");
                AnsiConsole.MarkupLine($"[dim]{error}[/]");

                if (response.StatusCode == System.Net.HttpStatusCode.Forbidden || response.StatusCode == System.Net.HttpStatusCode.TooManyRequests)
                {
                    if (TokenManager.HandleRateLimitError(new Exception("Rate limit"))) continue;
                }

                break;
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($"[red]âœ— Exception: {ex.Message}[/]");
                if (TokenManager.HandleRateLimitError(ex)) continue;
                break;
            }
        }
        
        if (!success)
        {
            AnsiConsole.MarkupLine($"[red]Gagal trigger bot {bot.Name}.[/]");
        }
    }
    
    // Legacy method (wrapper)
    public static async Task TriggerBotWithInputs(BotEntry bot, Dictionary<string, string> capturedInputs, int durationMinutes = 340)
    {
        await TriggerBotWithSecrets(bot, capturedInputs, null, durationMinutes);
    }
}

public class WorkflowRunsResponse
{
    [JsonPropertyName("workflow_runs")]
    public List<WorkflowRun>? WorkflowRuns { get; set; }
}

public class WorkflowRun
{
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    [JsonPropertyName("status")]
    public string? Status { get; set; }

    [JsonPropertyName("conclusion")]
    public string? Conclusion { get; set; }

    [JsonPropertyName("created_at")]
    public DateTime? CreatedAt { get; set; }

    [JsonPropertyName("updated_at")]
    public DateTime? UpdatedAt { get; set; }
}


on:
  workflow_dispatch:
    inputs:
      bot_name:
        description: 'Nama bot dari config'
        required: true
        type: string
      bot_path:
        description: 'Path bot (relatif dari root)'
        required: true
        type: string
      bot_repo:
        description: 'Repository URL'
        required: true
        type: string
      bot_type:
        description: 'Type: python or javascript'
        required: true
        type: string
      duration_minutes:
        description: 'Durasi run (menit, max 350)'
        required: false
        default: '340'
        type: string
      bot_inputs:
        description: 'JSON string input untuk bot (format: {"input_1":"y","input_2":"2"})'
        required: false
        default: '{}'
        type: string
      bot_secrets:
        description: 'Base64-encoded secrets (tokens/keys/wallets)'
        required: false
        default: ''
        type: string

jobs:
  run-bot:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(github.event.inputs.duration_minutes) }}

    steps:
      - name: Setup Python
        if: github.event.inputs.bot_type == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Setup Node.js
        if: github.event.inputs.bot_type == 'javascript'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Clone Bot Repository
        run: |
          echo "Cloning ${{ github.event.inputs.bot_name }}..."
          git clone --depth 1 "${{ github.event.inputs.bot_repo }}" bot
          cd bot
          ls -la

      - name: Parse & Create Input File
        working-directory: bot
        run: |
          echo "Creating auto-answer input file..."
          
          # Parse JSON input dari Orchestrator
          INPUT_JSON='${{ github.event.inputs.bot_inputs }}'
          
          # Convert JSON ke newline-separated text file
          echo "$INPUT_JSON" | jq -r 'to_entries | sort_by(.key) | .[].value' > bot_answers.txt
          
          echo "=== Auto-Answer File Created ==="
          cat bot_answers.txt
          echo "================================"
          
          LINE_COUNT=$(wc -l < bot_answers.txt)
          if [ "$LINE_COUNT" -eq 0 ]; then
            echo "WARNING: No answers provided. Bot may hang if interactive."
          else
            echo "Loaded $LINE_COUNT answers for auto-injection"
          fi
      
      - name: Inject Bot Secrets (Tokens/Keys/Wallets)
        working-directory: bot
        env:
          ENCRYPTION_KEY: ${{ secrets.SECRETS_ENCRYPTION_KEY }}
        run: |
          SECRETS_BASE64='${{ github.event.inputs.bot_secrets }}'
          
          if [ -z "$SECRETS_BASE64" ] || [ "$SECRETS_BASE64" = "null" ]; then
            echo "âš ï¸ WARNING: No secrets provided"
            echo "Bot may fail if it requires tokens/keys"
            exit 0
          fi
          
          echo "Decoding and injecting secrets..."
          
          # Decode base64 -> JSON
          SECRETS_JSON=$(echo "$SECRETS_BASE64" | base64 -d)
          
          # Check if encrypted (has ENCRYPTION_KEY env)
          if [ -n "$ENCRYPTION_KEY" ]; then
            echo "ðŸ” Encrypted mode detected"
            
            # Install decryption script dependencies
            pip install --quiet pycryptodome
            
            # Create Python decryption script
            cat > decrypt_secrets.py << 'DECRYPT_EOF'
import sys
import json
import base64
from Crypto.Cipher import AES

KEY_SIZE = 32
IV_SIZE = 12
TAG_SIZE = 16

def decrypt_aes_gcm(encrypted_base64, key_base64):
    try:
        key = base64.b64decode(key_base64)
        combined = base64.b64decode(encrypted_base64)
        
        # Extract IV, ciphertext, tag
        iv = combined[:IV_SIZE]
        ciphertext = combined[IV_SIZE:-TAG_SIZE]
        tag = combined[-TAG_SIZE:]
        
        # Decrypt
        cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        
        return plaintext.decode('utf-8')
    except Exception as e:
        print(f"Decryption error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    secrets_json = sys.argv[1]
    key = sys.argv[2]
    
    encrypted_dict = json.loads(secrets_json)
    decrypted_dict = {}
    
    for filename, encrypted_content in encrypted_dict.items():
        decrypted_dict[filename] = decrypt_aes_gcm(encrypted_content, key)
    
    print(json.dumps(decrypted_dict))
DECRYPT_EOF
            
            # Decrypt secrets
            SECRETS_JSON=$(python decrypt_secrets.py "$SECRETS_JSON" "$ENCRYPTION_KEY")
            
            if [ $? -ne 0 ]; then
              echo "âŒ ERROR: Decryption failed"
              echo "Check if SECRETS_ENCRYPTION_KEY is set correctly in GitHub Secrets"
              exit 1
            fi
            
            echo "âœ“ Secrets decrypted successfully"
          else
            echo "ðŸ“ Plaintext mode (no encryption)"
          fi
          
          # Extract dan save per file
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | "\(.key)|\(.value)"' | while IFS='|' read -r filepath content; do
            echo "Creating: $filepath"
            
            # Create parent dir jika perlu
            mkdir -p "$(dirname "$filepath")"
            
            # Save content (support multiline)
            echo "$content" > "$filepath"
            
            # Mask untuk security (jangan log full content)
            LINE_COUNT=$(echo "$content" | wc -l)
            echo "  âœ“ Saved ($LINE_COUNT lines)"
          done
          
          echo "âœ“ Secrets injection completed"
      
      - name: Install Python Dependencies
        if: github.event.inputs.bot_type == 'python'
        working-directory: bot
        run: |
          if [ -f "requirements.txt" ]; then
            pip install --no-cache-dir -r requirements.txt
          fi

      - name: Install Node Dependencies
        if: github.event.inputs.bot_type == 'javascript'
        working-directory: bot
        run: |
          if [ -f "package.json" ]; then
            npm install --silent
          fi

      - name: Run Bot (Python) with Auto-Answer
        if: github.event.inputs.bot_type == 'python'
        working-directory: bot
        run: |
          RUN_FILE=""
          if [ -f "run.py" ]; then
            RUN_FILE="run.py"
          elif [ -f "main.py" ]; then
            RUN_FILE="main.py"
          else
            echo "ERROR: No run.py or main.py found"
            exit 1
          fi
          
          # Jika ada answer file, inject via stdin
          if [ -s "bot_answers.txt" ]; then
            echo "Running with auto-answers..."
            timeout ${{ github.event.inputs.duration_minutes }}m python "$RUN_FILE" < bot_answers.txt || echo "Bot finished/timeout"
          else
            echo "Running without answers (may hang)..."
            timeout ${{ github.event.inputs.duration_minutes }}m python "$RUN_FILE" || echo "Bot finished/timeout"
          fi

      - name: Run Bot (JavaScript) with Auto-Answer
        if: github.event.inputs.bot_type == 'javascript'
        working-directory: bot
        run: |
          RUN_FILE=""
          if [ -f "index.js" ]; then
            RUN_FILE="index.js"
          elif [ -f "main.js" ]; then
            RUN_FILE="main.js"
          else
            echo "ERROR: No index.js or main.js found"
            exit 1
          fi
          
          # Jika ada answer file, inject via stdin
          if [ -s "bot_answers.txt" ]; then
            echo "Running with auto-answers..."
            timeout ${{ github.event.inputs.duration_minutes }}m node "$RUN_FILE" < bot_answers.txt || echo "Bot finished/timeout"
          else
            echo "Running without answers (may hang)..."
            timeout ${{ github.event.inputs.duration_minutes }}m node "$RUN_FILE" || echo "Bot finished/timeout"
          fi

      - name: Upload Logs (On Failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.event.inputs.bot_name }}-logs
          path: bot/**/*.log
          retention-days: 3
