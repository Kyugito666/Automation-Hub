using System.Net;
using System.Security.Cryptography; // Ditambahkan untuk SHA256
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Spectre.Console;

namespace Orchestrator;

public static class TokenManager
{
    // ... (Konstanta path file tetap sama) ...
     private static readonly string ConfigRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "config"));
    private static readonly string ProjectRoot = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", ".."));
    private static readonly string TokensPath = Path.Combine(ConfigRoot, "github_tokens.txt");
    private static readonly string MasterProxyListPath = Path.Combine(ProjectRoot, "proxysync", "proxy.txt"); // Master list generated by ProxySync
    private static readonly string SuccessProxyListPath = Path.Combine(ProjectRoot, "proxysync", "success_proxy.txt"); // List proxy yg lolos tes GitHub
    private static readonly string StatePath = Path.Combine(ProjectRoot, ".token-state.json");
    private static readonly string TokenCachePath = Path.Combine(ProjectRoot, ".token-cache.json");

    private static List<TokenEntry> _tokens = new();
    private static List<string> _availableProxies = new(); // Proxy yg lolos tes
    private static TokenState _state = new();
    private static Dictionary<string, string> _tokenCache = new();
    // Pool proxy per token untuk rotasi saat error
    private static Dictionary<string, Queue<string>> _proxyPool = new();

    // ... (Initialize, ReloadAllConfigs, LoadTokenCache, SaveTokenCache, LoadTokens tetap sama) ...
     public static void Initialize()
    {
        LoadTokens();
        LoadProxyList(); // Load proxy yg lolos tes
        LoadState();
        LoadTokenCache();
        AssignProxiesAndUsernames();
        InitializeProxyPool(); // Siapkan pool proxy untuk rotasi
    }

     public static void ReloadAllConfigs()
    {
        AnsiConsole.MarkupLine("[bold yellow]Reloading all configuration files...[/]");
        _tokens.Clear();
        _availableProxies.Clear();
        _tokenCache.Clear();
        _state = new TokenState();
        _proxyPool.Clear();

        Initialize();
        AnsiConsole.MarkupLine("[bold green]‚úì Konfigurasi berhasil di-refresh.[/]");
    }

    private static void LoadTokenCache() { /* ... */ }
    public static void SaveTokenCache(Dictionary<string, string> cache) { /* ... */ }
    private static void LoadTokens() { /* ... */ }


    private static void LoadProxyList()
    {
        // Prioritaskan success_proxy.txt jika ada
        string proxyFileToLoad = File.Exists(SuccessProxyListPath) ? SuccessProxyListPath : MasterProxyListPath;

        if (File.Exists(proxyFileToLoad))
        {
            try {
                _availableProxies = File.ReadAllLines(proxyFileToLoad)
                    .Select(line => line.Trim())
                    .Where(line => !string.IsNullOrWhiteSpace(line) && !line.StartsWith("#"))
                    .Distinct() // Pastikan unik
                    .ToList();

                if (proxyFileToLoad == SuccessProxyListPath)
                     AnsiConsole.MarkupLine($"[dim]Loaded {_availableProxies.Count} successfully tested proxies from {Path.GetFileName(proxyFileToLoad)}[/]");
                else
                     AnsiConsole.MarkupLine($"[yellow]Warning: {Path.GetFileName(SuccessProxyListPath)} not found. Loading from {Path.GetFileName(MasterProxyListPath)} ({_availableProxies.Count} proxies). Run ProxySync first![/]");

            } catch (Exception ex) {
                 AnsiConsole.MarkupLine($"[red]Error loading proxies from {proxyFileToLoad}: {ex.Message}[/]");
                 _availableProxies.Clear();
            }
        }
        else
        {
            AnsiConsole.MarkupLine($"[yellow]Warning: Proxy file not found ({Path.GetFileName(proxyFileToLoad)} or {Path.GetFileName(MasterProxyListPath)}). Running without proxies.[/]");
            _availableProxies.Clear();
        }
    }

    private static void AssignProxiesAndUsernames()
    {
        if (!_tokens.Any()) return;
        for (int i = 0; i < _tokens.Count; i++) {
            // Assign proxy (round-robin dari availableProxies)
            if (_availableProxies.Any()) {
                _tokens[i].Proxy = _availableProxies[i % _availableProxies.Count];
            } else {
                 _tokens[i].Proxy = null; // Tidak ada proxy
            }
            // Assign username
            if (_tokenCache.TryGetValue(_tokens[i].Token, out var username)) { _tokens[i].Username = username; }
        }
    }

    // Siapkan antrian proxy untuk setiap token
    private static void InitializeProxyPool()
    {
        _proxyPool.Clear();
        if (!_availableProxies.Any()) return; // Tidak ada proxy, tidak ada pool

        foreach (var tokenEntry in _tokens)
        {
            // Acak urutan proxy untuk setiap token agar beda
            var shuffledProxies = _availableProxies.OrderBy(x => Guid.NewGuid()).ToList();
            _proxyPool[tokenEntry.Token] = new Queue<string>(shuffledProxies);
        }
         AnsiConsole.MarkupLine($"[dim]Initialized proxy pool for {_proxyPool.Count} tokens.[/]");
    }

    // Logika rotasi proxy saat error (dipanggil dari CollaboratorManager/ShellHelper)
    public static bool RotateProxyForToken(TokenEntry currentTokenEntry)
    {
        if (!_proxyPool.TryGetValue(currentTokenEntry.Token, out var pool) || pool.Count == 0)
        {
            // Jika pool tidak ada atau sudah habis, reset pool untuk token ini
            AnsiConsole.MarkupLine($"[yellow]üîÑ Resetting proxy pool for token {MaskToken(currentTokenEntry.Token)}[/]");
             if (!_availableProxies.Any()) return false; // Tidak ada proxy sama sekali
             var shuffledProxies = _availableProxies.OrderBy(x => Guid.NewGuid()).ToList();
             pool = new Queue<string>(shuffledProxies);
             _proxyPool[currentTokenEntry.Token] = pool;
             // Jangan langsung Dequeue setelah reset, biarkan pemanggil coba lagi dengan proxy awal pool
             if (pool.Count > 0) {
                 currentTokenEntry.Proxy = pool.Peek(); // Set proxy ke yg pertama di pool baru
                 AnsiConsole.MarkupLine($"[dim]   Pool reset. Next proxy: {MaskProxy(currentTokenEntry.Proxy)}[/]");
                 return true; // Berhasil reset
             } else {
                 return false; // Tetap gagal jika _availableProxies kosong
             }
        }

        // Ambil proxy berikutnya dari pool
        var nextProxy = pool.Dequeue();
        currentTokenEntry.Proxy = nextProxy; // Ganti proxy di TokenEntry saat ini
        AnsiConsole.MarkupLine($"[yellow]üîÅ Proxy rotated to: {MaskProxy(nextProxy)} ({pool.Count} left in pool)[/]");
        return true; // Berhasil rotasi
    }


    // ... (LoadState, GetState, SaveState, GetCurrentToken, GetAllTokenEntries, GetUsernameCache tetap sama) ...
     private static void LoadState()
    {
        try { if (File.Exists(StatePath)) { var json = File.ReadAllText(StatePath); _state = JsonSerializer.Deserialize<TokenState>(json) ?? new TokenState(); } }
        catch (Exception ex) { AnsiConsole.MarkupLine($"[red]Error loading state: {ex.Message}. Resetting.[/]"); _state = new TokenState(); }
        if (_state.CurrentIndex >= _tokens.Count) { _state.CurrentIndex = 0; }
    }
    public static TokenState GetState() => _state;
    public static void SaveState(TokenState state) { _state = state; var json = JsonSerializer.Serialize(_state, new JsonSerializerOptions { WriteIndented = true }); try { File.WriteAllText(StatePath, json); } catch (Exception ex) { AnsiConsole.MarkupLine($"[red]Error saving state: {ex.Message}[/]"); } }
    public static TokenEntry GetCurrentToken() { if (!_tokens.Any()) throw new Exception("No tokens configured"); if (_state.CurrentIndex >= _tokens.Count) _state.CurrentIndex = 0; return _tokens[_state.CurrentIndex]; }
    public static List<TokenEntry> GetAllTokenEntries() => _tokens;
    public static Dictionary<string, string> GetUsernameCache() => _tokenCache;


    public static TokenEntry SwitchToNextToken()
    {
        if (!_tokens.Any() || _tokens.Count == 1) { AnsiConsole.MarkupLine("[yellow]Hanya 1 token, tidak bisa rotasi.[/]"); return GetCurrentToken(); }
        _state.CurrentIndex = (_state.CurrentIndex + 1) % _tokens.Count;
        _state.ActiveCodespaceName = null; // Penting: Hapus codespace aktif saat ganti token
        SaveState(_state); // Simpan state baru
        var current = _tokens[_state.CurrentIndex];
        AnsiConsole.MarkupLine($"[bold yellow]üîÅ Token Rotated[/]: Now using Token #{_state.CurrentIndex + 1} (@{current.Username ?? "???"})");
        if (!string.IsNullOrEmpty(current.Proxy)) { AnsiConsole.MarkupLine($"[dim]   Proxy: {MaskProxy(current.Proxy)}[/]"); } // Panggil MaskProxy public
        return current;
    }

    public static HttpClient CreateHttpClient(TokenEntry token)
    {
        // ... (Logika CreateHttpClient tetap sama) ...
         var handler = new HttpClientHandler();
         if (!string.IsNullOrEmpty(token.Proxy)) {
             try { handler.Proxy = new WebProxy(token.Proxy); handler.UseProxy = true; }
             catch (Exception ex) { AnsiConsole.MarkupLine($"[red]Invalid proxy format {MaskProxy(token.Proxy)}: {ex.Message}[/]"); } // Panggil MaskProxy public
         }
        var client = new HttpClient(handler);
        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {token.Token}");
        client.DefaultRequestHeaders.Add("User-Agent", "Automation-Hub-Orchestrator/3.1"); // Versi update
        client.DefaultRequestHeaders.Add("Accept", "application/vnd.github+json");
        return client;
    }

    public static string MaskToken(string token) { /* ... */ return token.Length > 10 ? token[..4] + "..." + token[^4..] : token; } // Masking lebih pendek

    // --- PERBAIKAN DI SINI ---
    public static string MaskProxy(string proxy) // <<< UBAH JADI PUBLIC
    // --- AKHIR PERBAIKAN ---
    {
        // ... (Isi method MaskProxy tetap sama) ...
         try {
            if (Uri.TryCreate(proxy, UriKind.Absolute, out var uri)) { return $"{uri.Scheme}://{uri.Host}:{uri.Port}"; }
            var parts = proxy.Split(':');
            if (parts.Length >= 2) { string hostPart = parts.Length > 2 ? parts[^2].Split('@').Last() : parts[^2]; string portPart = parts[^1]; return $"???://{hostPart}:{portPart}"; }
            return "masked-proxy";
        } catch { return "invalid-proxy-format"; }
    }

    public static void ShowStatus()
    {
        // ... (Logika ShowStatus tetap sama, panggil MaskProxy public) ...
         if (!_tokens.Any()) { AnsiConsole.MarkupLine("[yellow]No tokens loaded.[/]"); return; }
        AnsiConsole.MarkupLine($"[bold cyan]Owner:[/][yellow] {_tokens.FirstOrDefault()?.Owner ?? "N/A"}[/]");
        AnsiConsole.MarkupLine($"[bold cyan]Repo:[/][yellow] {_tokens.FirstOrDefault()?.Repo ?? "N/A"}[/]");
        AnsiConsole.MarkupLine($"[bold cyan]Active Codespace:[/][yellow] {_state.ActiveCodespaceName ?? "N/A"}[/]");

        var table = new Table().Title("GitHub Tokens Status").Expand();
        table.AddColumn("Index"); table.AddColumn("Token"); table.AddColumn("Username"); table.AddColumn("Proxy"); table.AddColumn("Active");
        for (int i = 0; i < _tokens.Count; i++) {
            var token = _tokens[i];
            var isActive = i == _state.CurrentIndex ? "[green]‚úì[/]" : "";
            var tokenDisplay = MaskToken(token.Token);
            var proxyDisplay = !string.IsNullOrEmpty(token.Proxy) ? MaskProxy(token.Proxy) : "[grey]none[/]"; // Panggil public MaskProxy
            table.AddRow((i + 1).ToString(), tokenDisplay, token.Username ?? "[grey]???[/]", proxyDisplay, isActive);
        }
        AnsiConsole.Write(table);
        AnsiConsole.MarkupLine($"[dim] Proxies available for rotation: {_availableProxies.Count}[/]");
    }
}

// --- Kelas Model (TokenEntry, TokenState) ---
public class TokenEntry { /* ... */ public string Token{get;set;}=string.Empty; public string? Proxy{get;set;} public string? Username{get;set;} public string Owner{get;set;}=string.Empty; public string Repo{get;set;}=string.Empty; }
public class TokenState { [JsonPropertyName("current_index")] public int CurrentIndex{get;set;}=0; [JsonPropertyName("active_codespace_name")] public string? ActiveCodespaceName{get;set;}=null; }
